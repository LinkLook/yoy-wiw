---
layout: post
title: 关于Common Lisp中广义函数，call-next-method，:around等的测试
permalink:
published:
category:
tags:
---
<h3>{{ page.title }}</h3>
<p>{{ page.date | date_to_string }}</p>
<p></p><p>关于Common Lisp中广义函数，call-next-method，:around等的测试</p><p></p><p>最近正在看Common Lisp，在看到广义函数和方法组合的时候，有点晕忽忽，索性写代码测试一翻，理解如下.</p><p></p><p>直接上代码：</p><p></p><p>(defclass s () ((name :initform "S" :reader get-name)))</p><p>(defclass a (s) ((name :initform "A" :reader get-name)))</p><p>(defclass b (s) ((name :initform "B" :reader get-name)))</p><p>(defclass me (a b) ((name :initform "Me" :reader get-name)))</p><p></p><p>;定义四个类，S是上帝，A是爸爸，B是妈妈，Me是我。</p><p>(defgeneric say-hello (s) (:documentation "Say hello")); 广义函数，传入一个参数。</p><p>(defmethod say-hello ((s s))</p><p>(format t "S:main say-hello! ~A~%" (get-name s))); 上帝主方法</p><p>(defmethod say-hello :around ((s s))</p><p>(format t "S:around say-hello! ~A~%" (get-name s))</p><p>(call-next-method)); 上帝around, 想一想去掉(call-next-method)会怎样</p><p>(defmethod say-hello :before ((s s))</p><p>(format t "S:before say-hello! ~A~%" (get-name s))); 上帝before</p><p>(defmethod say-hello :after ((s s))</p><p>(format t "S:after say-hello! ~A~%" (get-name s))); 上帝after</p><p></p><p>(say-hello (make-instance 's));想想输出什么</p><p>(format t "=======================~%")</p><p>(say-hello (make-instance 'a));想想输出什么</p><p>(format t "=======================~%")</p><p>(say-hello (make-instance 'me));想想输出什么</p><p>(format t "=======================~%")</p><p></p><p>(defmethod say-hello ((s a))</p><p>(format t "A:main say-hello! ~A~%" (get-name s))</p><p>(call-next-method)); 爸爸主方法, ,想一想去掉(call-next-method)会怎样</p><p>(defmethod say-hello :around ((s a))</p><p>(format t "A:around say-hello! ~A~%" (get-name s))</p><p>(call-next-method)); 爸爸around, ,想一想去掉(call-next-method)会怎样</p><p>(defmethod say-hello :before ((s a))</p><p>(format t "A:before say-hello! ~A~%" (get-name s))); 爸爸before</p><p>(defmethod say-hello :after ((s a))</p><p>(format t "A:after say-hello! ~A~%" (get-name s))); 爸爸after</p><p></p><p>(say-hello (make-instance 'a));想想输出什么</p><p>(format t "=======================~%")</p><p>(say-hello (make-instance 'me));想想输出什么</p><p>(format t "=======================~%")</p><p></p><p>(defmethod say-hello ((s b))</p><p>(format t "B:main say-hello! ~A~%" (get-name s))</p><p>(call-next-method)); 妈妈主方法, ,想一想去掉(call-next-method)会怎样</p><p>(defmethod say-hello :around ((s b))</p><p>(format t "B:around say-hello! ~A~%" (get-name s))</p><p>(call-next-method)); 妈妈around, ,想一想去掉(call-next-method)会怎样</p><p>(defmethod say-hello :before ((s b))</p><p>(format t "B:before say-hello! ~A~%" (get-name s))); 妈妈before</p><p>(defmethod say-hello :after ((s b))</p><p>(format t "B:after say-hello! ~A~%" (get-name s))); 妈妈after</p><p></p><p>(say-hello (make-instance 'b));想想输出什么</p><p>(format t "=======================~%")</p><p>(say-hello (make-instance 'me));想想输出什么</p><p>(format t "=======================~%")</p><p></p><p>(defmethod say-hello ((s me))</p><p>(format t "Me:main say-hello! ~A~%" (get-name s))</p><p>(call-next-method)); 我主方法, ,想一想去掉(call-next-method)会怎样</p><p>(defmethod say-hello :around ((s me))</p><p>(format t "Me:around say-hello! ~A~%" (get-name s))</p><p>(call-next-method)); 我around, ,想一想去掉(call-next-method)会怎样</p><p>(defmethod say-hello :before ((s me))</p><p>(format t "Me:before say-hello! ~A~%" (get-name s))); 我before</p><p>(defmethod say-hello :after ((s me))</p><p>(format t "Me:after say-hello! ~A~%" (get-name s))); 我after</p><p></p><p>(say-hello (make-instance 'Me));想想输出什么</p><p>(format t "=======================~%")</p><p></p><p>代码完成，现在解释一下：</p><p></p><p>类的继承关心是这样的(多重继承)：</p><p></p><p>S</p><p></p><p>A                    B</p><p></p><p>Me</p><p></p><p>广义函数只有一个，每个类都实现了该广义函数，并且:around, :before, :after都有，并且在主方法和around方法里都调用(call-next-method)。那么对于这个调用：</p><p></p><p>(say-hello (make-instance 'Me))执行情况如何呢？</p><p></p><p>首先要进行主方法排序: 根据最近优先原则，依次是：我，爸爸，妈妈，上帝。</p><p></p><p>所以整个顺序如下（16个方法）：</p><p></p><p>1. around在所有之前。around应该最先执行，依次是：我around,爸爸around,妈妈around,上帝around. 若中间某个around没有(call-next-method)，那么就此结束。</p><p></p><p>2. before在主方法之前：依次是：我before, 爸爸before,妈妈before, 上帝before.</p><p></p><p>3. 主方法：依次是：我主方法，爸爸主方法，妈妈主方法，上帝主方法。若中间某个主方法没有(call-next-method)，那么将不继续调用下面的主方法，而是直接调用之后的after方法。</p><p></p><p>4. after在主方法之后且倒序：依次是：上帝after, 妈妈after, 爸爸after, 我after。</p><p></p><p>注意1：若某一步的辅助方法（或主方法，主方法特殊，见注意2）不存在，则只跳过该方法，（15个方法）。</p><p></p><p>注意2：不可以只有辅助方法，而没有主方法。主方法是可以继承的，就是说如果上帝有主方法，而我们没有主方法，却有辅助方法是可以的。如果上帝没有主方法，却有辅助方法是不行的。</p><p></p><p>最后完整输出如下：</p><p></p><p>S:around say-hello! S</p><p>S:before say-hello! S</p><p>S:main say-hello! S</p><p>S:after say-hello! S</p><p>=======================</p><p>S:around say-hello! A</p><p>S:before say-hello! A</p><p>S:main say-hello! A</p><p>S:after say-hello! A</p><p>=======================</p><p>S:around say-hello! Me</p><p>S:before say-hello! Me</p><p>S:main say-hello! Me</p><p>S:after say-hello! Me</p><p>=======================</p><p>A:around say-hello! A</p><p>S:around say-hello! A</p><p>A:before say-hello! A</p><p>S:before say-hello! A</p><p>A:main say-hello! A</p><p>S:main say-hello! A</p><p>S:after say-hello! A</p><p>A:after say-hello! A</p><p>=======================</p><p>A:around say-hello! Me</p><p>S:around say-hello! Me</p><p>A:before say-hello! Me</p><p>S:before say-hello! Me</p><p>A:main say-hello! Me</p><p>S:main say-hello! Me</p><p>S:after say-hello! Me</p><p>A:after say-hello! Me</p><p>=======================</p><p>B:around say-hello! B</p><p>S:around say-hello! B</p><p>B:before say-hello! B</p><p>S:before say-hello! B</p><p>B:main say-hello! B</p><p>S:main say-hello! B</p><p>S:after say-hello! B</p><p>B:after say-hello! B</p><p>=======================</p><p>A:around say-hello! Me</p><p>B:around say-hello! Me</p><p>S:around say-hello! Me</p><p>A:before say-hello! Me</p><p>B:before say-hello! Me</p><p>S:before say-hello! Me</p><p>A:main say-hello! Me</p><p>B:main say-hello! Me</p><p>S:main say-hello! Me</p><p>S:after say-hello! Me</p><p>B:after say-hello! Me</p><p>A:after say-hello! Me</p><p>=======================</p><p>Me:around say-hello! Me</p><p>A:around say-hello! Me</p><p>B:around say-hello! Me</p><p>S:around say-hello! Me</p><p>Me:before say-hello! Me</p><p>A:before say-hello! Me</p><p>B:before say-hello! Me</p><p>S:before say-hello! Me</p><p>Me:main say-hello! Me</p><p>A:main say-hello! Me</p><p>B:main say-hello! Me</p><p>S:main say-hello! Me</p><p>S:after say-hello! Me</p><p>B:after say-hello! Me</p><p>A:after say-hello! Me</p><p>Me:after say-hello! Me</p><p>=======================</p><p></p><p>（完）</p><p></p><p>&nbsp;</p><p></p><p>&nbsp;</p><p>&nbsp;</p>