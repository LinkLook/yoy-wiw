---
layout: post
title: Zig-Zag编码及解码
permalink:
published:
category:
tags:
---
<h3>{{ page.title }}</h3>
<p>
Zig-Zag编码及解码的一个方法。
</p>
<p>{{ page.date | date_to_string }}</p>
<p>Zig-zag是一种蛇形编码，把一个矩阵转化为另一个矩阵，矩阵的行列相等。例如：</p>
<div>
{% highlight sh %}
A B C D           A B E I
E F G H    ==>    F C D G
I J K L    <==    J M N K
M N O P           H L O P
{% endhighlight %}
</div>
<p>
经过分析发现，编码后的行列与编码前的行列有对应关系，这种对应关系是有规律的。
</p>
<div>
{% highlight sh %}
行:0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3
列:0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3
转变为：
行:0 0 1 2 1 0 0 1 2 3 3 2 1 2 3 3 
列:0 1 0 0 1 2 3 2 1 0 1 2 3 3 2 3 
{% endhighlight %}
</div>
<p>发现转换后的行和列的队列是有规律的，所以可以写个程序构造这个队列。不难看出，第一个元素和最后一个元素与原矩阵相同，所以构造队列要从两头开始，中间汇合。</p>
<p>从第一个元素开始正向构造，然后从最后一个元素开始反向构造。接头的地方就是矩阵的对角线的下方。</p>
<div>
{% highlight c linenos %}
static void make_queue(int init, int *queue, int len)
{
  int i, tmp;
  int loop = init;

  i = 1;
  while(1){
    tmp = loop;
    while(loop > 0){
      queue[i]=queue[i-1]+1;
      if(++i >= len){return;}
      loop-- ;
    }
    while(loop < tmp){
      queue[i]=queue[i-1]-1;
      if(++i >= len){return;}
      loop++;
    }
    queue[i]=queue[i-1];
    if(++i >= len){return;}

    loop += 2;
  }
}
static void make_queue_backword(int init, int *queue, int start, int len)
{
  int i, tmp;
  int loop = init;

  i = len-2;
  while(1){
    tmp = loop;
    while(loop > 0){
      queue[i]=queue[i+1]-1;
      if(--i < start){return;}
      loop-- ;
    }
    while(loop < tmp){
      queue[i]=queue[i+1]+1;
      if(--i < start){return;}
      loop++;
    }
    queue[i]=queue[i+1];
    if(--i < start){return;}
    loop += 2;
  }
}
{% endhighlight %}
</div>
<p>构造好两个队列后就可以编码解码了，其实编码解码的过程差不多。解码就是把下标反映射回去。</p>
<div>
{% highlight c linenos %}
static void zig_zag(int *dest, int *src, unsigned int d, int decode)
{ 
  unsigned int m, i;
  unsigned int n = d*d;
  int * row_queue = malloc(sizeof(int)*n);
  int * col_queue = malloc(sizeof(int)*n);

  m = 0;
  for(i=1; i<=d; i++){
    m += i;
  }
  row_queue[0]=col_queue[0]=0;
  make_queue(0, row_queue, m);
  make_queue(1, col_queue, m);

  row_queue[n-1]=col_queue[n-1]=d-1;
  make_queue_backword(0, row_queue, m, n);
  make_queue_backword(1, col_queue, m, n);

  if(decode){
    for(m=0; m<n; m++){
      dest[row_queue[m]*d+col_queue[m]] = src[m];
    }
  }else{
    for(m=0; m<n; m++){
      dest[m]=src[row_queue[m]*d+col_queue[m]];
    }
  }

  free(row_queue);
  free(col_queue);
}
{% endhighlight %}
</div>
<p>
好了，测试一下：
</p>
<div>
{% highlight c linenos %}
static void zig_zag_test_print_matrix(int *q, int d)
{
  int i,j;
  for(i=0;i<d;i++){
    for(j=0; j<d; j++){
      fprintf(stdout, "%2d ", q[i*d+j]);
    }
    fprintf(stdout, "\n");
  }
}
static void zig_zag_test()
{
  int q[16]={0};
  int p[16];
  int i;
  int d = 4;
  int n = d*d;
  int m;

  m = 0;
  for(i=1; i<=d; i++){
    m += i;
  }
  for(i=0;i<n;i++){
    p[i]=i;
  }

  q[n-1]=d-1;
  q[0]=0;
  make_queue(0, q, m);
  make_queue_backword(0, q, m, n);
  for(i=0;i<n;i++){
    fprintf(stdout, "%d ", q[i]);
  }
  fprintf(stdout, "\n");
  make_queue(1, q, m);
  make_queue_backword(1, q, m, n);
  for(i=0;i<n;i++){
    fprintf(stdout, "%d ", q[i]);
  }
  fprintf(stdout, "\n");

  zig_zag(q, p, d, 0);
  zig_zag_test_print_matrix(q, d);
  fprintf(stdout, "==============\n");
  memcpy(p, q, sizeof(p));
  zig_zag(q, p, d, 1);
  zig_zag_test_print_matrix(q, d);
}
int main()
{
   zig_zag_test();
   return 0;
}
{% endhighlight %}
</div>
<p>方法有点笨，空间复杂性比较高，不知道有没有更好的方法。</p>
