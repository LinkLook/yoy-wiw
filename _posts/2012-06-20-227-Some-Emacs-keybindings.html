---
layout: post
title: Emacs常用命令
permalink:
published:
category:
tags:
---
<h3>{{ page.title }}</h3>
<p>{{ page.date | date_to_string }}</p>
<p></p><p><div align="left">Emacs 启动:</p><p>直接打emacs, 如果有X-windows就会开视窗. 如果不想用X 的版本,</p><p>就用 emacs -nw      (No windows)起动.</div></p><p><div align="left"><!--more--></div></p><p>符号说明</p><p>C-X 表示按住CTRL键, 然後按X, 再把CTRL, X一起放开.</p><p>M-X         META                 META</p><p></p><p>在没有META键的电脑上, M-X 等於先按 ESC键, 接著按 X键.</p><p>Sun上面META键就是菱形的那个键.</p><p>有些系统META键就是ALT键.(或者某一边的ALT键)</p><p></p><p>C-X或 M-X的X没有大小写分别.</p><p>Emacs按键命令基本上是一串C-&lt;chr&gt;和M-&lt;chr&gt;组成的.</p><p>超过两个以上的按键命令, Emacs会在萤幕最下面一行显示你按过什麽.</p><p>这一行叫作mini buffer</p><p></p><p>结束Emacs按 C-x C-c</p><p></p><p>取消执行 C-g</p><p>有些Emacs命令会跑很久, 可以用C-g中断之. 按错键也可以按C-g取消.</p><p></p><p>上下移动   C-p 向上 (previous line) C-n向下(next line)</p><p>左右移动   C-f 向右 (forward) C-b 向左 (backward)</p><p></p><p>其实Emacs内部没有行的概念, 把一篇文章放在一个大buffer</p><p>里面, 所以C-f (forward)就是向档尾移动, C-b (backward)</p><p>是移回去的意思, 一次一个字.</p><p></p><p>翻页  下一页 C-v (view next screen)</p><p>上一页 M-v</p><p></p><p>翻页时,上一  末尾会留一点在萤幕最上面,以维持连续性.</p><p></p><p>Emacs在游标接近萤幕最下方时会自动跳半页, 把档案往前挪一点,</p><p>方便阅读.</p><p></p><p>重画萤幕 C-L</p><p></p><p>Emacs里面游标的专有名词叫point. point == 游标目前的 点</p><p></p><p>游标一次跳一个字(word) M-f  往後跳 M-b</p><p></p><p>注意 C-f 与 M-f, C-b 与 M-b的对称性.</p><p></p><p>移到行头 C-a  行尾 C-e</p><p>移到句首 M-a  到句尾 M-e</p><p>(M-a 到上一个句点後面,一个句子的起头.</p><p>M-e 到句点後面)</p><p></p><p>移到档头 M-&lt; 档尾 M-&gt;</p><p></p><p>删除游标目前指的/後面的字 C-d</p><p>前面的字 DEL  (Delete键)</p><p>DEL的正名叫Rubout (Rub out)</p><p></p><p>M-DEL 往回删一个字(word)</p><p>M-d   往前删 (游标後面)</p><p>C-k   删至行尾 (kill)</p><p>M-k   删到一句子结尾(删到句点) (kill)</p><p>注意Backspace = C-h 在Emacs下是help的意思</p><p>後面有(kill)的, 表示此删除的动作是kill, 不太等於delete.</p><p>emacs会把kill掉的东西放到kill ring去, 算是一种暂存的地方,</p><p>以後可以叫出来.见 yank说明.</p><p>Undo: C-x u</p><p>C-_ 等於 C-x u    有些DEC终端机, C-/就是C-_</p><p>有时等於C-Shift- -</p><p></p><p>重复执行</p><p></p><p>举例, 向右移 8个字, C-u 8 C-f</p><p>C-u 在Emacs里是蛮特别的,用来设定一些引数(argument/repeat count)</p><p>给其後的命令.</p><p></p><p>C-u 2 0 C-n 向下移 20行</p><p></p><p>有一个特别的例外, C-u 3 C-v 不是翻三页, 而是整个萤幕向上移三行.</p><p>据说这比较有意义.</p><p></p><p>C-u 1 0 C-x u   UNDO 10次</p><p></p><p>给C-L一个引数会怎麽样:</p><p>C-u 0 C-l 会重画萤幕,并且把目前的行移到萤幕第一行.</p><p></p><p>另外, C-u 100   等於 M-100</p><p>C-u 数字  等於 M-数字</p><p></p><p>X windows 下,</p><p>C-left C-right 一次移一个字(word).</p><p>C-up C-down 移动一段 (paragraphs/C语言的话是block)</p><p>Home = C-a</p><p>End = C-e</p><p>C-Home = M-&lt;</p><p>C-end = M-&gt;</p><p>PgUp PgDn = M-v C-v</p><p>设定重覆次数更加简单,</p><p>比如要向右移10个字 C-1 C-0 right-arrow</p><p>就是按住CTRL, 然後打10就对了, 比 C-u 1 0 简单.</p><p></p><p>Mouse中键用来选取有hi-light的地方.</p><p>右键是menu-button</p><p></p><p>如果不小心按两次ESC, 等於 M-ESC,  会有一个讯息跑出来</p><p>说你按到一个被disable的命令. 这是高级指令, 作者认为</p><p>初学者用不道,所以会问你要不要启动它, 一般回答no.</p><p></p><p>如果某一行太长, 萤幕显示不下, Emacs会在萤幕最右边打个$,</p><p>表示此行未完,右边还有.</p><p></p><p>把一行拆成两行: 在想拆处按Enter即可.</p><p>合并两行为一行: 在行尾按C-d (或行首按DEL)</p><p></p><p>Yank: 吐出被删掉的(killed)东西.</p><p></p><p>只要用kill (C-k, M-k等) 删除, 超过一个字的资料,</p><p>emacs就会把它存起来, 然後C-y 可以把它叫出来.</p><p>功能跟Cut &amp; Paste一样. Kill 和delete不一样, 只有被</p><p>kill掉的东西才能用yank吐回来.</p><p></p><p>游标在同一地方不动, 连续kill掉的资料会被当成一次kill掉的,</p><p>yank时会一起回来.</p><p></p><p>被Kill掉的资料是放在称作 kill ring的资料结构上面, ring就是个圆圈,</p><p>被kill掉的东西会依序摆在圆圈上. yank 会放回最近一次kill掉的资料.</p><p>如果不是你想要的话, 用M-y 可以换.  (M-y就是告诉emacs, 不对不对,</p><p>我不是要这一个,换前一个给我).</p><p></p><p>M-y 要紧接在C-y之後.</p><p></p><p>拷贝文字的方法== 连续 C-k 几次,  把要拷贝的行全部删掉,</p><p>然後按 C-y 弄回来. 再到想复制的地方按一次C-y, 就成了.</p><p></p><p>把要拷贝的资料kill掉在yank回来好像很笨. 是有比较文明的</p><p>方法, 那就是M-w, 不过较麻烦.</p><p></p><p>首先,要先设标记. Mark 用 C-SPC 或 C-@ 设. 然候</p><p>把游标移到另一端, 按 M-w 就可以把 mark 到 point间的</p><p>字存到kill ring上. point 就是游标的意思.</p><p></p><p>Emacs不会把Mark起来的地方用highlight表示, 除非在X下.</p><p>在X下, 可以用M-w 来拷贝用滑鼠反白的文字.</p><p></p><p>kill &amp; yank 就是 cut &amp; paste的意思.</p><p>以上大部份指令对Bash的命令列编辑也有效</p><p></p><p>档案操作</p><p>读档: Emacs术语叫 finding a file.</p><p>C-x C-f 然後在mini-buffer输入档名. 输入档名时, SPC键有</p><p>auto-complete的功能,或者会秀出到目前为止档名前几</p><p>个字和输入一样的. (TAB键也有类似功能)</p><p></p><p>C-x C-f 叫 find-file</p><p></p><p>C-x C-s 存档 (save current file, save current buffer)</p><p>C-x s   存所有的档</p><p></p><p>C-x i   插入档案  把另外的档案的内容读入目前编辑区内</p><p></p><p>视窗</p><p>Emacs把档案读进来,存在buffer中.</p><p>我们透过window来看/编辑buffer.</p><p></p><p>两个视窗会把萤幕切成两部份, 他们可以同时显示</p><p>相同的, 或不同的档案.</p><p></p><p>对初学者而言, 最需要的是记住怎样让不想要的视窗消失:</p><p></p><p>C-x 0 关掉目前的视窗</p><p>C-x 1 会让目前的视窗占满整个萤幕 (One Window),</p><p>取消/关掉其他的视窗.</p><p></p><p>Emacs里面有许多功能都会开一个小视窗来和使用者沟通, 显示讯息.</p><p>有时候不会自动消失很讨厌, C-x 1 就很有用.</p><p></p><p>另一个功能是如何跳到另一个视窗.</p><p>C-x o  (other-window)</p><p>C-x 2 把目前的视窗切成两个 (水平分割)</p><p>C-x 3                      (垂直分割)</p><p>C-x 4 是一串与视窗有关的指令.</p><p>C-x 4 是一串与视窗有关的指令.</p><p>C-x 5 则是扩展到X的视窗, 称为frame.</p><p>C-x 5 2 就是再开另一个X视窗 (frame).</p><p>多档编辑</p><p>C-x C-b 看目前有那些buffer (buffer就是emacs放开起的档案的地方).</p><p>C-x b 然後在minibuffer输入buffer的名字,可以切换编辑buffer.</p><p>TAB键也有作用. 有些内部的buffer (就是没有档案的buffer),</p><p>是用*开头和结束, 这个也要打, 如*scratch*</p><p></p><p>最候提醒:</p><p>C-x 1 可以把多馀的视窗关掉.</p><p>Emacs扩充指令</p><p></p><p>前面介绍的emacs按键大部份都是C-&lt;chr&gt; 或者 M-&lt;chr&gt;的形式.</p><p>这是最简单的按法, 由一对按键构成一个指令.</p><p></p><p>Emacs的按键可以超过2个以上. 如 C-x 1 或 C-x C-b.</p><p>一般超过一个按键组合的命令都是用C-x 开头.</p><p></p><p>另外你也可以直接下命令. 按 M-x 之後就可以打一个Emacs命</p><p>令来执行. 一般这些命令名字都很长, 不过都不常用. 等一下</p><p>我们会介绍一些. 还有介绍怎麽把这些命令设成按键指令.</p><p></p><p>C-x C-c 就是结束Emacs. 不过一般Emacs很笨重, 一旦起动就不轻易</p><p>退出. 所以比较常用的是C-z</p><p></p><p>C-z 把Emacs暂停, 回到命令列. 当你下次再需要编辑时,打fg %emacs</p><p>就可以把Emacs唤醒.</p><p></p><p>在X下, C-z会把emacs缩成icon</p><p>mode line</p><p></p><p>emacs编辑画面由 编辑区(buffer) 状态列 (modeline) 和对话区 (minibuffer)</p><p>构成. 这里解释 modeline 显示的讯息.</p><p></p><p>以下是个范例:</p><p></p><p>--**-XEmacs: xemacs.qs      (Fundamental)----74%-------</p><p></p><p>由後面往前解释, 74% 表示游标的位置.</p><p></p><p>(Fundamental)表示编辑模式.这是最原始的模式. 编辑不同种类的文章</p><p>可能希望用不同的模式, 比如说C-mode, lisp-mode, tex-mode, text-mode</p><p>等等. 在不同模式下可能多一些按键出来. 举例text-mode.</p><p>M-x text-mode</p><p>可以切入text-mode, 这是一般人编辑文字使用的模式. 和Fundamental mode</p><p>没什麽差异. 不过游标移动时, Emacs对一个字的定义就有所不同, 因而</p><p>M-f M-b 等移动一个字, 一个段落的指令就可能会停在标点符号的前面.</p><p>此时状态列变为... (Text)----70%---</p><p></p><p>以上说的是Major mode. 另外还有minor mode, 其实就是一些额外的功能.</p><p>比如说, M-x auto-fill-mode 则状态列显示 (Text Fill).</p><p>auto-fill就是自动断行, 让文章每行固定有70个字.</p><p></p><p>M-X fundamental-mode 可以变回来.</p><p></p><p>这里要说明一下, emacs在 minibuffer下有auto-completion的功能,</p><p>也就是打M-x fund 然後按 SPC, 它会自动补全 fundamental-mode,</p><p>不用全打. 如果有两个以上的选择, 它会告诉你. 这个功能对</p><p>find-file (C-x C-f)等等档案编辑功能也有效. 前面提过.</p><p>最後解释两个**号. 右边的*表示文章被修改过了.</p><p>左边的* 表示这个编辑区(buffer)可以修改.</p><p>有一些emacs的buffer是read-only buffer, 就会标成%</p><p>%%表示档案是read-only.</p><p></p><p>C-x C-q 可以解开read-only的锁定, 无论如何你要改这个编辑区.</p><p>这是个toggle指令, 如果原来是可以修改的, C-x C-q会把它切成</p><p>read-only.</p><p>Search</p><p></p><p>没有Search 功能的编辑器简直就是小朋友的玩具. Search</p><p>是一项很重要的功能, 所以emacs也提供的很完善.</p><p>C-s</p><p>C-r</p><p>M-x re-search-forward</p><p>M-x re-search-backward</p><p>M-x search-forward</p><p>M-x search-backward</p><p>以上这些指令是基本的search指令. C-s, C-r是increamental search,</p><p>就是你打字的同时, emacs就直接帮你找. 一个是forward, 一个是backward.</p><p>找到了怎麽办? 按C-g可以取消搜寻, 跳回原来的位置. 按Enter就让游标</p><p>停在找到的地方 -- 此时minibuffer显示:Mark saved where search started</p><p>什麽意思? 就是isearch帮你在原来的位置设了一个mark, 然後把point</p><p>(cursor) 移到新的位置.</p><p>想跳回去原先的地方?</p><p>C-x C-x 就可以了.(exchange-point-and-mark)</p><p>C-u C-SPC 可以依序跳回前几次设mark的地方.</p><p>(C-SPC是设mark, 给它一个argument, 就是反动作)</p><p>(还记不记得C-u 可以给後面的指令设一些参数.</p><p>有些指令拿这个参数来当作repeat count,</p><p>有些指令就只拿来当作on/off, true/false, set/clear而已)</p><p></p><p>M-x re-search-forward可以让你用regular expression搜寻.</p><p>M-x search-forward则没有increamental的功能.</p><p></p><p>另外一个指令, 作用和grep很像:</p><p>M-x occure</p><p></p><p>和search相提并论的就是replace.</p><p>M-x replace 然後按 SPC, 就知道了.</p><p></p><p>Emacs的设定:</p><p></p><p>Emacs的设定档是 $HOME/.emacs</p><p>你应该多少知道, emacs是用lisp写成的编辑器, .emacs档也都是</p><p>要用lisp的语法设定. emacs用的lisp称为elisp, 和一般的lisp差一点点.</p><p></p><p>有一个info page, emacs-lisp-intro, 深入浅出的介绍emacs lisp.</p><p>如果你还不会, 不懂programming, 强烈建议你看这份文件. 如果你</p><p>会texinfo, 你可以把它很漂亮的印出来. (内容一点点而已, 两三</p><p>天就看完了)</p><p></p><p>如果你把.emacs搞砸了, 进emacs很奇怪, 怎麽办?</p><p>1. 用 vi 改 .emacs :&gt;</p><p>2. emacs -q 进 emacs</p><p>Major Modes</p><p></p><p>一般常见的emacs major mode有</p><p>fundamental-mode</p><p>text-mode</p><p>lisp-mode   有自动对括号/重排, 直接执行lisp code功能.</p><p>c-mode/cc-mode c-mode是比较旧的c-mode, cc-mode应该是</p><p>目前新的c-mode. 有自动重排/对括号的功能.</p><p>也可以在emacs内compile, 跳到compiler error</p><p>修正错误. 执行程式时debug. (配合dbx/gdb)</p><p>compile是透过Makefile进行.</p><p>tex-mode    Tex/Latex编辑模示. 可能是打一些奇怪的标点</p><p>符号比较方便.</p><p>&lt;programming-language&gt;-mode</p><p>同lisp/cc-mode. 如果是interpreter的话,</p><p>emacs通常都可以直接执行/debug.</p><p>&lt;programming-language&gt;-mode还有tags的功能, 後述.</p><p></p><p>html-mode, texinfo-mode, sgml-mode: 编写html, texi, sgml之用.</p><p>w3-mode     WWW browser. 在x-win上不满意,但可以接受...</p><p>Tags</p><p></p><p>Tags 是一个显为人知的功能? 所以我想提一下. 这不是emacs发明的,</p><p>而是vi 原本的特异功能. emacs只是发扬光大而已.</p><p>假设你有一个目录, 里面是一个程式的原始码, 比如说, tin 的原始码,</p><p>放在 ~/tin-1.3beta 下面. 你想看它们.</p><p></p><p>首先, 叫emacs cd到该目录:</p><p>M-x cd</p><p></p><p>然後, 建立tag table.</p><p>tag table 就是一张对照表, 记录哪个符号(variable/function call)</p><p>对映到哪个档案的哪个地方. 有这张表, emacs可以让我们快速的在程</p><p>式码内游走. 一般这张表是一个档案, 叫作TAGS (大写)</p><p></p><p>M-! etags *.[ch]</p><p></p><p>M-! 是执行external shell command的意思. etags就是emacs的建表程式.</p><p>你只要告诉它你的source code在那□即可.</p><p></p><p>vi的话是使用ctags这个程式, 它建出来的档名叫tags (小写). 因为</p><p>我们介绍emacs, 所以不管它.</p><p></p><p>然後, 怎麽看程式? 你知道所有的C 程式都是由main()开始, 所以你想</p><p>找到main()在哪个档案. 这时只要按  M-. 然後emacs会问你tag table</p><p>在哪里. 因为我们已经cd到该目录, 直接按enter就好了. 然後输入main,</p><p>emacs就会把你带到main(){ ... }去.</p><p></p><p>如果 你看到某个程式片断呼叫一个你没看过的函式, 你可以把游标</p><p>移到该函式的名字上, M-. ENTER 就搞定了.</p><p></p><p>如果 emacs找错了 (比如有变数和函式同名, emacs跳到变数去),</p><p>那你可以用 C-u M-. 找下一个.</p><p></p><p>在编辑程式码的时候, M-SPC 很有用, 它会把游标附近的空白缩成一个.</p><p>在其它地方也有效.</p><p></p><p>Emacs的一些package:</p><p></p><p>M-x dired  (或C-x d)</p><p>游走/编辑 目录, 就是档案总管的意思 :)</p><p></p><p>M-x man   就是man page</p><p>M-x shell 开个command prompt, 不过不能跑vi,elm, tin...</p><p>M-x gnus  读新闻/读信</p><p>M-x rmail 读信</p><p>M-x vm    view mail</p><p>M-x mh-rmail 读信 (package mh-e)</p><p>M-x mh-smail 送信 (package mh-e)</p><p></p><p>强列建议改用emacs读news/bbs. 世界会更美好!</p><p></p><p>读信的话就要看你的感觉. 这些读信程式都会把信从系统的mail folder</p><p>搬到自己的目录下, 占用quota, 我不喜欢 :p 建议elm或mutt.</p><p>除非参加mailling list配合procmail. 不然不实用.</p><p>用mh-e 须要装mh 这个外部程式, 不太好. 建议vm 或 gnus.</p><p>写完信, C-c C-c 就可以送信.</p><p></p><p>如果你的资料用rcs/sccs作版本管理, emacs自动会起动version control</p><p>(minor mode.), c-x c-q 变成check-in/check-out.</p><p></p><p>如何取得更多的资讯:</p><p></p><p>Emacs的lisp 经过多年的发展,已成为完整的self-documenting系统.</p><p>很多东西都可以线上找到你要的资讯.</p><p></p><p>前面说过,或者你已经不小心按backspace遇到了, C-h (就是backspace</p><p>的ascii码) 在emacs里面是help的意思, 它可以带出一串指令.</p><p>常用的有:</p><p></p><p>C-h F   Emacs FAQ</p><p>C-h t   Emacs 使用教学</p><p>C-h n   Emacs NEWS file, 介绍最近改版的新功能</p><p>C-h i   Info system. Info是gnu用来取代man page的系统,</p><p>基本上和文字模示的WWW差不多. 有许多重要的资讯</p><p>可以在这边找到. 如果你是新手, 建议你在x-win下</p><p>看. 不然, 按键 m (menuitem), SPC next page</p><p>l (last node: node就是章节的意思) u (up node)</p><p>d (directory, 索引). BS (Backspace, back a page).</p><p>如果全部只按SPC, 就跟man 一样.</p><p>C-h k   describe key, 告诉你按这个键执行那个lisp function.</p><p>C-h f   describe function. 告诉你function在作什麽.</p><p>如果只按SPC, emacs会给你所有lisp 函数的列表, 和说明.</p><p>C-h v   describe variable 同function.</p><p>C-h a   apropos的意思(approximate).  给lisp function的部份</p><p>字串, emacs帮你找.</p><p>C-h b   列出目前所有的keybinding</p><p>C-h m   mode help. 列出目前的mode的特殊说明.</p><p>C-c C-h 列出以C-c 开头的所有key-binding. 虽然说Emacs</p><p>可以定义按键, 可是Ctrl- 开头的所有组合大概都用光了,</p><p>只有C-c算是可以自定指令. 不过有些mode也侵犯这个空间.</p><p>目前的convention是C-c &lt;chr&gt; 留给user, C-c C-&lt;chr&gt;</p><p>留给package.</p><p></p><p>有以上这些help, 你的emacs/elisp功力会随著时间成长.</p><p>Elisp 简介:</p><p></p><p>Emacs有三份手册.第一份是使用手册, 第二份是Elisp 手册, 第三份是</p><p>Elisp 简介.  第三份的程度是入门级, 值得看. Elisp手册其实也写的</p><p>很简单, 还教你lisp, 不过有点长, 适合参考.</p><p></p><p>因为我lisp没有仔细学过, 所以:</p><p>以下所言, 如有巧合, 那才是真的.</p><p></p><p>Basic data type</p><p>字串 (string) "Hello, World"</p><p>字元 (char)  ?a               ; 问号开头</p><p>atom &amp; list:</p><p>(1 2 3 4)  是一个list, 由 4个 atom 组成.</p><p>pair:  中间是句点.</p><p>(apple . 2)</p><p>alist (associated list)</p><p>就是一堆 pair的集合,就像perl/tcl的associative array.</p><p>或者说是一个资料库, 一堆 (key, value) pair.</p><p>'((Apple     . 1)</p><p>(Orange    . 2)</p><p>(PineApple . 3))</p><p>vector (?)</p><p>emacs 19用vector 来表示按键(key strok sequence)</p><p>[f1] [f2] [f1 a]</p><p></p><p>nil  就是空的list, 或者表示 false</p><p>t    true</p><p>Forms</p><p>我们写程式最好有样版让我们填空最简单了.</p><p>Form 就是样版, 不过意义不太一样.</p><p>Form 就是Elisp 可以接受的句型.</p><p>lisp 解译器 预设是对list的每个元素求值(evaluate),</p><p>除非是 special form, 有特殊的定义. 比如说</p><p></p><p>(defun FUNC (ARG-LIST)</p><p>BODY ...)</p><p>就是一个special form, 用来定义函式, 所以FUNC 不会被</p><p>求值, 被当成symbol, ...</p><p></p><p>(quote (LIST))</p><p></p><p>这也是个special form, 叫 lisp 把 (LIST)当做symbol就好了,</p><p>不要 evaluate.</p><p></p><p>quote 很常用, 所以有个缩写:</p><p>'(LIST)  等於 (quote (LIST))</p><p>'Asymbol 可以表示一个Atom, 名称叫Asymbol</p><p></p><p>set 可以产生/定义新的变数.</p><p>(set 'hello 1)</p><p>; hello = 1</p><p>; 注意我们用 'hello, 所以lisp不会evaluate hello的值.</p><p></p><p>这家伙很常用, 也有简写.</p><p>(setq hello 1)</p><p>setq 就是set quote 的缩写. 这是个 special form, 不会对</p><p>第二个元素求值.</p><p>valuation</p><p></p><p>在Emacs下, C-x C-e 可以执行(evaluate, 求值)游标左边的叙述.</p><p>结果会出现在minibuffer.</p><p></p><p>lisp-interaction-mode中 C-j 可以evaluate, 并且把结果append到 buffer.</p><p></p><p>lisp 程式由一堆list 构成.称为expression.</p><p>每个expression 都回传回一个值.</p><p>有些expression有副作用, 如删掉一个字.</p><p>(这跟C 的int delete_char() 意思一样, 它传回int,</p><p>并且删掉某个char)</p><p></p><p>定义函式:</p><p></p><p>(defun NAME (ARGS-LIST)</p><p>"注解"                  ; optional</p><p>(interactive)           ; optional</p><p>BODY)</p><p></p><p>定义一个叫NAME的函式. BODY 是一堆expression.</p><p>注解是用来给C-h f显示的.</p><p>(interactive) 表示这个函示会和user/buffer作用.</p><p>(interactive "B") 表示执行此函式先问user一个buffer的名字,</p><p>然後当作参数传给它. (如, 当user透过key-binding</p><p>或者 M-x 呼叫此函式时)</p><p>(interactive "BAppend to buffer: \nr")</p><p>问user buffer name时, 提示号 Append to buffer:</p><p>此function有两个引数,第一个是B, 就是buffer</p><p>第二个是r, region</p><p>用\n 隔开.</p><p>(interactive "p") 用C-u 设的prefix 把它当作参数传给我.</p><p>预设值==4. C-u C-f 向右移四个字</p><p></p><p>一些lisp 函式:</p><p></p><p>(list 1 2 3 4)   产生 '(1 2 3 4)</p><p>(car '(1 2 3 4)       1</p><p>(cdr '(1 2 3 4)       '(2 3 4)</p><p>(cons 1 '(2 3 4))     '(1 2 3 4)</p><p>(cons 1 2)            (1 . 2)</p><p>(cons 0 (cons 1  (cons 2 nil)))</p><p>等於  '(0 1 2)</p><p>{list 是用 pair 串起来的,</p><p>用C 表示:</p><p>pair: {Object *first, Object *second};</p><p>*(pair[i].first) == i;</p><p>pair[i].second == pair[i+1]; }</p><p></p><p>(cons '(1 2) '(3 4))  '((1 2) 3 4)</p><p>(setq a 1)</p><p>(1+ a)        ; a+1</p><p>(+ 2 a)       ; a+2</p><p>(* 1 2 3 4)</p><p>(current-buffer)  ; 传回目前buffer的资料物件</p><p>(switch-to-buffer (other-buffer))</p><p>(set-buffer)</p><p>(buffer-size)</p><p>(setq current-pos (point))</p><p>(point-min)</p><p>(point-max)</p><p>(message "Hello")   ; 在minibuffer显示Hello</p><p>(if (test)</p><p>(then-part)</p><p>(else-part))</p><p>(cond ((test1) BODY1)</p><p>((test2) BODY2)</p><p>(t  OTHER-WISE)</p><p>(let ((var1 value)  ; local variable</p><p>var2             ; no value</p><p>(var3 value)</p><p>...)</p><p>BODY ...)</p><p>(lambda (ARG-LIST) ...) 同 defun, 但是没有名字 (anonymous).</p><p>可以存到变数去:</p><p>(setq hello (lambda () (message "Hello,World")))</p><p>(funcall hello)</p><p>(goto-char (point-max))</p><p>(defvar VAR VALUE "*注解") 如果VAR 不存在才定义. 有注解可以用</p><p>C-h v 看. 注解打*号表是使用者可以直接改/ 这个变数本来就是</p><p>给使用者设定用的.</p><p>可以用 M-x edit-options 来线上设定 (emacs结束就没有了,</p><p>不过edit-options可以给你所有可修改的变数的列表,你可以</p><p>放到.emacs档内.</p><p></p><p>(directory-files "./" t "\\..*")</p><p>return a list of files under directory X</p><p>(load "xxxx.el")  同#include &lt;stdio.h&gt;</p><p>给使用者设定用的.</p><p>可以用 M-x edit-options 来线上设定 (emacs结束就没有了,</p><p>不过edit-options可以给你所有可修改的变数的列表,你可以</p><p>放到.emacs档内.</p><p></p><p>(directory-files "./" t "\\..*")</p><p>return a list of files under directory X</p><p>(load "xxxx.el")  同#include &lt;stdio.h&gt;</p><p>(setq load-path (cons "~/emacs" load-path)) ; load的search path.</p><p>(autoload ...) 不像load会直接evaluate 整个档案, 而是需要时再</p><p>load.</p><p>(local-unset-key [(control c)])</p><p>(local-set-key [(control c) a] 'forward-sexp)</p><p>sexp 就是一个expession, n个expression如果用括号括起来就算一个.</p><p>(expression的定义随语言的不同而有不同, 在C, lisp</p><p>tex, html, fortran 下皆有差异)</p><p></p><p>#来自JOYFIRE</p><p></p><p>&nbsp;</p><p></p><p><a href="http://blog.csdn.net/joans123/article/details/6628325">Emacs 函数、变量列表</a></p><p></p><p>学习过程中见到的列出来，以后会继续修正</p><p></p><p>------------ 杂项 ----------------------------</p><p>user-mail-address    邮件地址</p><p>mail-host-address    主机邮件地址</p><p>user-login-name        登录用户名</p><p>user-full-name        用户全称</p><p>system-name        系统名称</p><p>system-type          返回系统类型</p><p>set-time-zone-rule    设置时区</p><p>fboundp            符号为非空函数返回t</p><p>eobp            如果当前点是buffer的最后返回t</p><p>bobp            如果当前点是buffer的开始返回t</p><p>bolp            如果当前点位于行首返回t</p><p>eolp            如果当前点位于行尾返回t</p><p>point-marker        返回当前点位置的marker</p><p>point-to-register     保存当前位点到指定寄存器</p><p></p><p>sit-for            重新显示,并等待几秒</p><p>recenter        以位点为中心重新显示</p><p>make-local-variable    设置为本地变量</p><p>start-process        运行子程序,返回进程</p><p>set-process-sentinel    设置进程守卫，当进程状态改变时调用(两个参数，进程和状态字符串)</p><p>set-process-query-on-exit-flag  当Emacs退出时，进程还在运行提示</p><p>process-buffer        获取进程使用的buffer</p><p>delete-process        删除进程</p><p></p><p></p><p></p><p>------------ buffer -------------------------</p><p>buffer-list        列出所有打开的buffer</p><p>switch-to-buffer    切换buffer</p><p>set-buffer-modified-p     设置当前buffer的改变状态</p><p>delete-region        删除指定区域</p><p>marker-buffer        返回marker的buffer</p><p>marker-position        返回marker的位点</p><p>get-buffer        返回指定名称的buffer</p><p>bury-buffer        埋葬buffer</p><p>kill-buffer        杀掉buffer</p><p>get-buffer-create    获取或者创建buffer</p><p>set-buffer        设置当前buffer</p><p>buffer-disable-undo    buffer禁用undo</p><p>erase-buffer        插入buffer内容</p><p>display-buffer        在窗口中显示buffer，当不选中</p><p></p><p></p><p>------------ 字符串 --------------------------</p><p>regexp-quote        返回精确匹配指定字符串的正则表达式</p><p>substring        取字符串的子串,负数表示倒数第几个字符</p><p>search-forward        向前搜索</p><p>re-search-forward    从当前位点向前搜索正则表达式</p><p>match-begining         返回匹配字符串的第一个位点</p><p>match-end        返回匹配字符串的最后一个位点</p><p>skip-chars-forward    跳过指定字符</p><p>read-from-minibuffer    从minibuffer读入数据</p><p>add-text-properties    添加属性到文本块</p><p>buffer-substring-no-properties 返回不带属性的字符串</p><p>posn-point        返回位点对应的buffer</p><p>event-restart        返回事件的开始位点</p><p>looking-at        向前匹配正则表达式</p><p>re-search-backward    向后搜索正着表达式</p><p></p><p></p><p></p><p>------------ 文件操作 -------------------------</p><p>expand-file-name    扩展文件名称为绝对路径</p><p>file-name-directory       获取文件的路径,不包括文件名</p><p>file-name-nondirectory    获取文件名,不包括文件名</p><p>directory-file-name    返回路径的文件名</p><p>file-name-as-directory    返回文件名的路径形式</p><p></p><p>file-remote-p        判断一个文件是否是远程系统文件,是的话返回远程主机标识</p><p>file-accessible-directory-p    如果文件存在且是目录,并且有open权限则返回t</p><p>file-readable-p            如果文件存在且可读则返回t</p><p>make-directory            创建目录</p><p>read-file-name            读入一个文件名</p><p>file-directory-p        判断是否是目录</p><p>find-file-noselect        不选中的查找文件</p><p>insert-file-contents        在当前位点插入文件中的内容</p><p></p><p>------------ 界面 -----------------------------</p><p>add-menu-button            添加按钮</p><p>easy-menu-define        定义菜单条</p><p></p><p>make-keymap            生成键盘映射表</p><p>define-key            在keymap中定义按键</p><p>suppress-keymap            删除子插入的键</p><p>user-local-map            使用本地映射</p><p>make-sparse-keymap        生成稀疏映射表</p><p></p><p></p><p>------------ 钩子 -----------------------------</p><p>find-file-hooks            找到文件是调用</p><p>find-file-not-found-hooks    找不到文件时调用</p><p>write-file-hooks        buffer输出前调用</p><p></p><p>after-init-hook            初始化完之后调用</p><p>c++-mode-hook                   进入C++模式时调用</p><p>c-mode-hook            进入c模式时调用</p><p></p><p>&nbsp;</p><p>&nbsp;</p>
